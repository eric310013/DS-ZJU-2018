# 中国大学MOOC-陈越、何钦铭-数据结构-2018秋期末考试

## 判断题（共 5 小题，共计 10 分）

1-1 在一个有向图中，所有顶点的入度与出度之和等于所有边之和的2倍。 (2分)

- [x] T
- [ ] F

1-2 采用平方探测冲突解决策略（$h_i(k)=(H(k)+i^2)\%11$, 注意：不是$±i^2$），将一批散列值均等于2的对象连续插入一个大小为11的散列表中，那么第4个对象一定位于下标为0的位置。 (2分)

- [x] T
- [ ] F

1-3 $N\log{N^2}和$N\log{N}$具有相同的增长速度。 (2分)

- [x] T
- [ ] F

1-4 对N个不同的数据采用冒泡排序进行从大到小的排序，当元素基本有序时交换元素次数肯定最多。 (2分)

- [ ] T
- [x] F

1-5 若一棵平衡二叉树的所有非叶结点的平衡因子都是0，则其必为完美二叉树。(2分)

- [x] T
- [ ] F

## 单选题（共 22 小题，共计 64 分）

2-1 给定输入序列 {4371, 1323, 6173, 4199, 4344, 9679, 1989} 以及散列函数$h(X)=X\%10$。如果用大小为10的散列表，并且用分离链接法解决冲突，则输入各项经散列后在表中的下标为：（-1表示相应的插入无法成功）(4分)

- [ ] 1, 3, 4, 9, 7, 5, -1
- [x] 1, 3, 3, 9, 4, 9, 9
- [ ] 1, 3, 4, 9, 5, 0, 8
- [ ] 1, 3, 4, 9, 5, 0, 2

2-2 数据结构中Dijkstra算法用来解决哪个问题？ (2分)

- [ ] 拓扑排序
- [ ] 字符串匹配
- [ ] 关键路径
- [x] 最短路径

2-3 给定一有向图的邻接表如下。若从v1开始利用此邻接表做广度优先搜索得到的顶点序列为：{v1, v3, v2, v4, v5}，则该邻接表中顺序填空的结果应为： (2分)

![2-3](image/2-3.jpg)

- [x] v3, v2, v4
- [ ] v4, v3, v2
- [ ] v2, v3, v4
- [ ] v3, v4, v2

2-4 在一个链队列中，front和rear分别为头指针和尾指针，则插入一个结点s的操作为（ ）。 (2分)

- [ ] s->next=rear; rear=s;
- [x] rear->next=s; rear=s;
- [ ] front=front->next;
- [ ] s->next=front; front=s;

2-5

给定二叉树如下图所示。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列为3、1、7、5、6、2、4，则其遍历方式是： (2分)

![2-5](image/2-5.jpg)

- [ ] LRN
- [ ] RLN
- [ ] NRL
- [x] RNL

2-6 设栈S和队列Q的初始状态均为空，元素a、b、c、d、e、f、g依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是b、d、c、f、e、a、g，则栈S的容量至少是： (2分)

- [x] 3
- [ ] 4
- [ ] 1
- [ ] 2

2-7 在一个有权无向图中，如果顶点b到顶点a的最短路径长度是10，顶点c与顶点b之间存在一条长度为3的边。那么下列说法中有几句是正确的？ (4分)

>c与a的最短路径长度就是13</br>
c与a的最短路径长度就是7</br>
c与a的最短路径长度不超过13</br>
c与a的最短路径不小于7

- [ ] 3句
- [ ] 1句
- [x] 2句
- [ ] 4句

2-8 哈夫曼树是n个带权叶子结点构成的所有二叉树中（）最小的二叉树。 (2分)

- [ ] 权值
- [ ] 高度
- [x] 带权路径长度
- [ ] 度

2-9 将 { 10, 12, 1, 14, 6, 5, 8, 15, 3, 9, 7 } 逐个按顺序插入到初始为空的最小堆中，然后连续执行两次删除最小元素操作（`DeleteMin`），再插入4，16，此后堆顶的元素是什么？ (4分)

- [ ] 7
- [x] 4
- [ ] 5
- [ ] 9

2-10 要判断一个整数N（>10）是否素数，我们需要检查3到$\sqrt{N}$之间是否存在奇数可以整除N。则这个算法的时间复杂度是：(2分)

- [ ] $O(\sqrt{N}\log{N})$
- [x] $O(\sqrt{N})$
- [ ] $O(N/2)$
- [ ] $O(0.5\log{N})$

2-11 设最小堆（小根堆）的层序遍历结果为{5, 18, 15, 28, 22, 42, 40}。用线性时间复杂度的算法将该堆调整为最大堆（大根堆），则该树的中序遍历结果为：(4分)

- [x] 18, 28, 22, 42, 15, 40, 5
- [ ] 22, 5, 18, 42, 40, 15, 28
- [ ] 18, 28, 22, 15, 40, 5, 42
- [ ] 5, 22, 18, 42, 15, 40, 28

2-12 将 8, 9, 7, 2, 3, 5, 6, 4 顺序插入一棵初始为空的AVL树。下列句子中哪句是错的？ (4分)

- [ ] 3 和 8 是兄弟
- [ ] 7 是根结点
- [x] 5 是 8 的父结点
- [ ] 4 和 6 是兄弟

2-13 在并查集问题中，已知集合元素0~8所以对应的父结点编号值分别是{ 1, -4, 1, 1, -3, 4, 4, 8, -2 }（注：−n表示树根且对应集合大小为n），那么将元素6和8所在的集合合并（要求必须将小集合并到大集合）后，该集合对应的树根和父结点编号值分别是多少？ (4分)

- [x] 4和-5
- [ ] 8和-5
- [ ] 1和-6
- [ ] 8和-6

2-14 在拓扑排序算法中用堆栈和用队列产生的结果会不同吗？(2分)

- [ ] 肯定是相同的
- [ ] 以上全不对
- [ ] 是的肯定不同
- [x] 有可能会不同

2-15 设一个栈的输入序列是1、2、3、4、5，则下列序列中，是栈的合法输出序列的是？ (4分)

- [ ] 5 1 2 3 4
- [ ] 4 5 1 3 2
- [ ] 4 3 1 2 5
- [x] 3 2 1 5 4

2-16 给定初始待排序列{ 15，9，7，8，20，-1，4 }。如果希尔排序第一趟结束后得到序列为{ 15，-1，4，8，20，9，7 }，则该趟增量为： (4分)

- [ ] 3
- [ ] 1
- [ ] 2
- [x] 4

2-17 给出关键字序列{ 4321, 56, 57, 46, 28, 7, 331, 33, 234, 63 }，下面哪个选择是按次位优先（LSD）链式基数排序进行了一趟分配和收集的结果？ (2分)

- [x] →4321→331→33→63→234→56→46→57→7→28
- [ ] →56→28→4321→331→33→234→46→57→63→7
- [ ] →57→46→28→7→33→234→63→56→4321→331
- [ ] →331→4321→33→63→234→56→46→57→7→28 

2-18 将序列{ 2, 12, 16, 88, 5, 10, 34 }排序。若前2趟排序的结果如下：

>第1趟排序后：2, 12, 16, 10, 5, 34, 88</br>
第2趟排序后：2, 5, 10, 12, 16, 34, 88

则可能的排序算法是：(2分)

- [x] 快速排序
- [ ] 冒泡排序
- [ ] 归并排序
- [ ] 插入排序

2-19 将1~6这6个键值插到一棵初始为空的二叉搜索树中。如果插入完成后，搜索树结构如图所示，问：可能的插入序列是什么？ (2分)

![2-19](image/2-19.jpg)

- [x] 4 1 3 2 5 6
- [ ] 1 2 3 4 5 6
- [ ] 4 1 2 3 5 6
- [ ] 4 1 3 2 6 5

2-20

设数字 {4371, 1323, 6173, 4199, 4344, 9679, 1989} 在大小为10的散列表中根据散列函数$h(X)=X\%10$得到的下标对应为 {1, 3, 4, 9, 5, 0, 2}。那么继续用散列函数“$h(X)=X\%表长$”实施再散列并用线性探测法解决冲突后，它们的下标变为：(4分)

- [ ] 1, 3, 4, 9, 5, 0, 2
- [ ] 11, 3, 13, 19, 4, 0, 9
- [x] 1, 12, 9, 13, 20, 19, 11
- [ ] 1, 12, 17, 0, 13, 8, 14

2-21 在图中自d点开始进行深度优先遍历算法可能得到的结果为： (2分)

- [ ] d,a,e,b,c,f
- [x] d,e,a,c,f,b
- [ ] d,a,c,f,e,b
- [ ] d,f,c,e,a,b

2-22 给定有权无向图的邻接矩阵如下，其最小生成树的总权重是：(4分)

![2-22](image/2-22.jpg)

- [ ] 22
- [ ] 15
- [ ] 20
- [x] 8

## 程序填空题（共 2 小题，共计 18 分）

5-1 下列代码的功能是将小顶堆`H`中指定位置`P`上的元素的整数键值下调`D`个单位，然后继续将`H`调整为小顶堆。

```C
void DecreaseKey( int P, int D, PriorityQueue H )
{
   int i, key;
   key = H->Elements[P] - D;
   for ( i = P/*(3分)*/; H->Elements[i/2] > key; i/=2 )
        H->Elements[i] = H->Elements[i/2]/*(3分)*/;
   H->Elements[i] = key;
}
```

5-2 下列代码的功能是将一列元素{`r[1] … r[n]`}按非递减顺序排序。普通选择排序是每次仅将一个待排序列的最小元放到正确的位置上，而这个另类的选择排序是每次从待排序列中同时找到最小元和最大元，把它们放到最终的正确位置上。

```C
void sort( list r[], int n )  
{
   int i, j, mini, maxi;

   for (i=1; i<n-i+1; i++) {
      mini = maxi = i;
      for( j=i+1; j<=n-i+1/*(3分)*/; ++j ){
         if( r[j]->key < r[mini]->key/*(3分)*/ ) mini = j; 
         else if(r[j]->key > r[maxi]->key) maxi = j;
      }
      if( mini != i/*(3分)*/ ) swap(&r[mini], &r[i]);
      if( maxi != n-i+1 ){
         if( maxi != n-i+1/*(3分)*/ ) swap(&r[mini], &r[n-i+1]);
         else swap(&r[maxi], &r[n-i+1]);
      }
   }
}
```

## 编程题（共 1 小题，共计 8 分）

### 7-1 根据后序和中序遍历输出先序遍历 （8 分）

本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的先序遍历结果。

#### 输入格式

第一行给出正整数$N(≤30)$，是树中结点的个数。随后两行，每行给出$N$个整数，分别对应后序遍历和中序遍历结果，数字间以空格分隔。题目保证输入正确对应一棵二叉树。

#### 输出格式

在一行中输出`Preorder:`以及该树的先序遍历结果。数字间有1个空格，行末不得有多余空格。

#### 输入样例

```bash
7
2 3 1 5 7 6 4
1 2 3 4 5 6 7
```

#### 输出样例

```bash
Preorder: 4 1 3 2 6 5 7
```

```C
#include "iostream"
#include "cstdio"

const int maxn = 30;
int count = 0;

void get_preorder(int n, int* postorder, int* inorder, int* preorder) {
    if (n <= 0)
        return;
    preorder[count++] = postorder[n - 1];
    int i;
    for (i = 0; i < n; i++)
    {
        if (inorder[i] == postorder[n - 1]) {
            break;
        }
    }
    get_preorder(i, postorder, inorder, preorder);
    get_preorder(n - i - 1, postorder + i, inorder + i + 1, preorder);
}

int main()
{
    int n;
    int postorder[maxn], inorder[maxn], preorder[maxn];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &postorder[i]);
    }
    for (int i = 0; i < n; i++) {
        scanf("%d", &inorder[i]);
    }
    get_preorder(n, postorder, inorder, preorder);
    printf("Preorder:");
    for (int i = 0; i < n; i++) {
        printf(" %d", preorder[i]);
    }
    return 0;
}
```
